@using CMC.Web.FormFields
@using CMC.Web.Services
@inherits FormFieldBase
@inject IRelationshipManager Rels

<div class="form-row">
    <label class="form-label">@Label</label>

    @if (_isLoading)
    {
        <div class="form-control" style="padding: 8px;">
            <span>Lade Optionen...</span>
        </div>
    }
    else if (_options.Count == 0)
    {
        <div class="form-control" style="padding: 8px;">
            <span class="text-muted">Keine Optionen verf√ºgbar</span>
        </div>
    }
    else
    {
        <div class="checkbox-list">
            @foreach (var option in _options)
            {
                var isChecked = _selectedKeys.Contains(option.Value);
                <label class="chk-inline">
                    <input type="checkbox"
                           checked="@isChecked"
                           disabled="@ReadOnly"
                           @onchange="@(e => HandleCheckboxChange(option.Value, e))" />
                    @option.Key
                </label>
            }
        </div>
    }

    @if (!string.IsNullOrWhiteSpace(Hint))
    {
        <div class="form-hint">@Hint</div>
    }
</div>

@code {
    [Parameter] public string RelationName { get; set; } = "";
    [Parameter] public Type? ParentType { get; set; }

    private bool _isLoading = true;
    private List<KeyValuePair<string, string>> _options = new();
    private HashSet<string> _selectedKeys = new(StringComparer.OrdinalIgnoreCase);

    protected override async Task OnParametersSetAsync()
    {
        await LoadOptionsAsync();
        UpdateSelectedFromValue();
    }

    private async Task LoadOptionsAsync()
    {
        _options.Clear();

        if (ParentType is null || string.IsNullOrWhiteSpace(RelationName))
        {
            _isLoading = false;
            return;
        }

        try
        {
            _isLoading = true;

            // robust: erst direkte Nav, dann Alias (ParentType.Name + RelationName)
            var descriptor = TryGetDescriptor(RelationName)
                          ?? TryGetDescriptor(ParentType.Name + RelationName);

            if (descriptor is null || descriptor.Kind != RelationKind.ManyToMany)
            {
                _isLoading = false;
                return;
            }

            var relationOptions = await descriptor.LoadOptions();
            _options = relationOptions.Select(o => new KeyValuePair<string, string>(o.Label, o.Value)).ToList();

            Console.WriteLine($"[CheckboxList] Parent={ParentType?.Name}, Rel={RelationName}, Found=True, Kind={descriptor.Kind}");
            Console.WriteLine($"[CheckboxList] Options count = {_options.Count}");
        }
        catch
        {
            _options = new();
        }
        finally
        {
            _isLoading = false;
        }
    }

    private RelationDescriptor? TryGetDescriptor(string rel)
    {
        try { return Rels.GetDescriptor(ParentType!, rel); }
        catch { return null; }
    }

    private void UpdateSelectedFromValue()
    {
        _selectedKeys.Clear();

        if (Value is IEnumerable<string> strings)
        {
            foreach (var key in strings)
                if (!string.IsNullOrWhiteSpace(key))
                    _selectedKeys.Add(key);
            return;
        }

        if (Value is System.Collections.IEnumerable seq && Value is not string)
        {
            foreach (var item in seq)
            {
                var s = item?.ToString();
                if (!string.IsNullOrWhiteSpace(s))
                    _selectedKeys.Add(s);
            }
        }
    }

    private async Task HandleCheckboxChange(string optionValue, ChangeEventArgs e)
    {
        var isChecked = e.Value?.ToString() == "on" || (e.Value is bool b && b);

        if (isChecked) _selectedKeys.Add(optionValue);
        else _selectedKeys.Remove(optionValue);

        await OnChanged(_selectedKeys.ToList());
    }
}
