@using System.ComponentModel.DataAnnotations
@using System.Reflection
@using System.Linq
@using Microsoft.AspNetCore.Components
@using CMC.Web.Services
@using CMC.Web.Util
@using CMC.Web.FormFields
@using CMC.Web.FormFields.Types
@using CMC.Contracts.Common

<div class="form-grid">
    @foreach (var field in GetFormFields())
    {
        @RenderFormField(field)
    }
</div>

@code {
    [Parameter] public object? Model { get; set; }
    [Parameter] public List<ExtraField> ExtraFields { get; set; } = new();
    [Parameter] public EventCallback<(string Name, object? Value)> OnFieldChanged { get; set; }
    [Parameter] public EFEditRequest Request { get; set; } = default!;
    [Parameter] public IDictionary<string, object?>? ValueOverrides { get; set; }

    private List<FormFieldDescriptor> GetFormFields()
    {
        var fields = new List<FormFieldDescriptor>();

        if (Model != null)
        {
            foreach (var prop in GetVisibleProps())
                fields.Add(CreateFieldFromProperty(prop));
        }

        foreach (var extra in ExtraFields ?? new())
            fields.Add(CreateFieldFromExtra(extra));

        return fields;
    }

    private FormFieldDescriptor CreateFieldFromProperty(PropertyInfo prop)
    {
        var pType   = EffectiveType(prop.PropertyType);
        var label   = GetDisplayName(prop) ?? prop.Name;
        var current = ResolveCurrentValue(prop.Name, prop.GetValue(Model!));
        var hint    = GetHint(prop);

        // Im Editor „read-only“ markieren, wenn ausdrücklich EditorHidden – (wir blenden sie über GetVisibleProps ohnehin aus)
        var readOnly = prop.GetCustomAttribute<EditorHiddenAttribute>() != null;

        // --- 1) Attribut-basierte Relation ---
        var relAttr = prop.GetCustomAttribute<RelationFromAttribute>();
        if (relAttr != null && Request.EfParentType != null)
        {
            var relationName = TryGetRelationName(relAttr)
                               ?? DeriveRelationName(prop.Name, isMany: relAttr.IsMany);

            if (relAttr.IsMany)
                current = NormalizeKeys(current);

            return new FormFieldDescriptor(
                Name: prop.Name,
                Label: label,
                FieldType: relAttr.IsMany ? typeof(CheckboxListField) : typeof(RelationSelectField),
                ValueType: prop.PropertyType,
                ReadOnly: readOnly,
                Hint: hint,
                Value: current,
                Parameters: new()
                {
                    ["RelationName"] = relationName,
                    ["ParentType"]   = Request.EfParentType
                }
            );
        }

        // --- 2) Heuristik: *Ids => Many-to-Many Checkboxen ---
        if (Request.EfParentType != null &&
            typeof(System.Collections.IEnumerable).IsAssignableFrom(pType) &&
            pType != typeof(string) &&
            prop.Name.EndsWith("Ids", StringComparison.Ordinal))
        {
            var relationName = DeriveRelationName(prop.Name, isMany: true);
            current = NormalizeKeys(current);

            return new FormFieldDescriptor(
                Name: prop.Name,
                Label: label,
                FieldType: typeof(CheckboxListField),
                ValueType: prop.PropertyType,
                ReadOnly: readOnly,
                Hint: hint,
                Value: current,
                Parameters: new()
                {
                    ["RelationName"] = relationName,
                    ["ParentType"]   = Request.EfParentType
                }
            );
        }

        // --- 3) Heuristik: *Id (Guid/String) => Single-Reference Select ---
        if (Request.EfParentType != null &&
            (pType == typeof(Guid) || pType == typeof(Guid?) || pType == typeof(string)) &&
            prop.Name.EndsWith("Id", StringComparison.Ordinal) &&
            !prop.Name.EndsWith("Ids", StringComparison.Ordinal))
        {
            var relationName = DeriveRelationName(prop.Name, isMany: false); // z.B. CustomerId -> "Customer"

            return new FormFieldDescriptor(
                Name: prop.Name,
                Label: label,
                FieldType: typeof(RelationSelectField),
                ValueType: prop.PropertyType,
                ReadOnly: readOnly,
                Hint: hint,
                Value: current,
                Parameters: new()
                {
                    ["RelationName"] = relationName,
                    ["ParentType"]   = Request.EfParentType
                }
            );
        }

        // --- 4) Standard-Feld ---
        var fieldType  = GetFieldTypeForProperty(pType);
        var parameters = GetParametersForProperty(pType, prop);

        return new FormFieldDescriptor(
            Name: prop.Name,
            Label: label,
            FieldType: fieldType,
            ValueType: prop.PropertyType,
            ReadOnly: readOnly,
            Hint: hint,
            Value: current,
            Parameters: parameters
        );
    }

    private FormFieldDescriptor CreateFieldFromExtra(ExtraField extra)
    {
        var fieldType  = GetFieldTypeForExtra(extra);
        var parameters = GetParametersForExtra(extra);

        return new FormFieldDescriptor(
            Name:  extra.Name,
            Label: string.IsNullOrWhiteSpace(extra.Label) ? extra.Name : extra.Label,
            FieldType: fieldType,
            ValueType: extra.Type,
            ReadOnly: extra.ReadOnly,
            Hint: extra.Hint,
            Value: ResolveCurrentValue(extra.Name, extra.Value),
            Parameters: parameters
        );
    }

    // ---------- Hilfen ----------
    private object? ResolveCurrentValue(string name, object? modelValue)
        => (ValueOverrides != null && ValueOverrides.TryGetValue(name, out var v)) ? v : modelValue;

    private static object? NormalizeKeys(object? value)
    {
        if (value is null) return null;
        if (value is System.Collections.IEnumerable seq && value is not string)
        {
            var list = new List<string>();
            foreach (var e in seq)
                if (e != null)
                    list.Add(e.ToString()!);
            return list;
        }
        return value;
    }

    private static string? TryGetRelationName(RelationFromAttribute attr)
    {
        var t = attr.GetType();
        foreach (var name in new[] { "RelationName", "Name", "Relation", "Navigation", "Property" })
        {
            var p = t.GetProperty(name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
            var val = p?.GetValue(attr)?.ToString();
            if (!string.IsNullOrWhiteSpace(val))
                return val;
        }
        return null;
    }

    private Type GetFieldTypeForProperty(Type propType) => TypeCodeOf(propType) switch
    {
        TypeCode.Boolean => typeof(CheckboxField),
        TypeCode.DateTime => typeof(DateTimeField),
        TypeCode.Decimal or TypeCode.Double or TypeCode.Single => typeof(NumberField),
        TypeCode.Int16 or TypeCode.Int32 or TypeCode.Int64 or
        TypeCode.UInt16 or TypeCode.UInt32 or TypeCode.UInt64 => typeof(NumberField),
        _ when propType == typeof(Guid) || propType == typeof(Guid?) => typeof(TextField),
        _ => typeof(TextField)
    };

    private Dictionary<string, object> GetParametersForProperty(Type propType, PropertyInfo prop)
    {
        var parameters = new Dictionary<string, object>();
        var typeCode   = TypeCodeOf(propType);

        switch (typeCode)
        {
            case TypeCode.DateTime:
                parameters["InputType"] = "datetime-local";
                break;

            case TypeCode.Decimal or TypeCode.Double or TypeCode.Single:
                parameters["InputType"] = "number";
                parameters["Step"]      = "any";
                break;

            case TypeCode.Int16 or TypeCode.Int32 or TypeCode.Int64 or
                 TypeCode.UInt16 or TypeCode.UInt32 or TypeCode.UInt64:
                parameters["InputType"] = "number";
                parameters["Step"]      = "1";
                break;

            case TypeCode.String:
                if (prop.Name.Contains("Password", StringComparison.OrdinalIgnoreCase))
                {
                    parameters["InputType"]    = "password";
                    parameters["Autocomplete"] = "new-password";
                }
                break;
        }

        if (propType == typeof(Guid) || propType == typeof(Guid?))
            parameters["ReadOnly"] = false; // Guid im Editor NICHT readonly, falls als Textfeld gerendert würde

        return parameters;
    }

    private Type GetFieldTypeForExtra(ExtraField extra)
    {
        if (string.Equals(extra.DataType, "relation-auto", StringComparison.OrdinalIgnoreCase))
        {
            if (extra.Type.IsGenericType && extra.Type.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                return typeof(CheckboxListField);
            return typeof(RelationSelectField);
        }

        if (string.Equals(extra.DataType, "password", StringComparison.OrdinalIgnoreCase))
            return typeof(TextField);

        if (extra.Options?.Any() == true)
            return typeof(SelectField);

        return typeof(TextField);
    }

    private Dictionary<string, object> GetParametersForExtra(ExtraField extra)
    {
        var parameters = new Dictionary<string, object>();

        if (string.Equals(extra.DataType, "relation-auto", StringComparison.OrdinalIgnoreCase))
        {
            var relationName = DeriveRelationName(extra.Name,
                isMany: extra.Type.IsGenericType && extra.Type.GetGenericTypeDefinition() == typeof(IEnumerable<>));

            parameters["RelationName"] = relationName;
            if (Request.EfParentType != null)
                parameters["ParentType"] = Request.EfParentType;
        }
        else if (string.Equals(extra.DataType, "password", StringComparison.OrdinalIgnoreCase))
        {
            parameters["InputType"]    = "password";
            parameters["Autocomplete"] = "new-password";
        }
        else if (extra.Options?.Any() == true)
        {
            parameters["Options"] = extra.Options;
        }

        return parameters;
    }

    private RenderFragment RenderFormField(FormFieldDescriptor descriptor) => builder =>
    {
        int seq = 0;
        builder.OpenComponent(seq++, descriptor.FieldType);
        builder.AddAttribute(seq++, nameof(FormFieldBase.Name),  descriptor.Name);
        builder.AddAttribute(seq++, nameof(FormFieldBase.Label), descriptor.Label);
        builder.AddAttribute(seq++, nameof(FormFieldBase.Value), descriptor.Value);
        builder.AddAttribute(seq++, nameof(FormFieldBase.ReadOnly),  descriptor.ReadOnly);
        builder.AddAttribute(seq++, nameof(FormFieldBase.Required),  descriptor.Required);

        if (!string.IsNullOrWhiteSpace(descriptor.Hint))
            builder.AddAttribute(seq++, nameof(FormFieldBase.Hint), descriptor.Hint);

        builder.AddAttribute(seq++, nameof(FormFieldBase.OnValueChanged),
            EventCallback.Factory.Create<object?>(this, value => OnFieldChanged.InvokeAsync((descriptor.Name, value))));

        foreach (var param in descriptor.Parameters)
            builder.AddAttribute(seq++, param.Key, param.Value);

        builder.CloseComponent();
    };

    private IEnumerable<PropertyInfo> GetVisibleProps()
{
    if (Model is null) yield break;

    var type = Model.GetType();
    var allProps = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                       .Where(p => p.CanRead)
                       .ToList();

    foreach (var p in allProps)
    {
        // Primärschlüssel nie anzeigen
        if (string.Equals(p.Name, "Id", StringComparison.Ordinal)) continue;

        var effective = EffectiveType(p.PropertyType);

        var isRelationCandidate =
            p.GetCustomAttribute<RelationFromAttribute>() != null ||
            (p.Name.EndsWith("Ids", StringComparison.Ordinal) &&
             typeof(System.Collections.IEnumerable).IsAssignableFrom(effective) &&
             effective != typeof(string)) ||
            // Exakt "Id" nicht als Relation behandeln:
            (p.Name.EndsWith("Id", StringComparison.Ordinal) &&
             !string.Equals(p.Name, "Id", StringComparison.Ordinal) &&
             (effective == typeof(Guid) || effective == typeof(Guid?) || effective == typeof(string)));

        var scaffold = p.GetCustomAttribute<ScaffoldColumnAttribute>();
        if (scaffold is { Scaffold: false } && !isRelationCandidate) continue;

        var disp = p.GetCustomAttribute<DisplayAttribute>();
        if (disp?.GetAutoGenerateField() == false && !isRelationCandidate) continue;

        if (p.GetCustomAttribute<EditorHiddenAttribute>() is not null && !isRelationCandidate) continue;

        yield return p;
    }
}

    // --- Namensableitung für Relationen (mit einfacher Pluralisierung) ---
    private static string DeriveRelationName(string fieldName, bool isMany)
    {
        var baseName =
            fieldName.EndsWith("Ids", StringComparison.Ordinal) ? fieldName[..^3] :
            fieldName.EndsWith("Id",  StringComparison.Ordinal) ? fieldName[..^2] :
            fieldName;

        if (!isMany) return baseName;

        return baseName.EndsWith("y", StringComparison.OrdinalIgnoreCase)
            ? baseName[..^1] + "ies"
            : baseName + "s";
    }

    private static string? GetDisplayName(PropertyInfo p)
        => p.GetCustomAttribute<DisplayAttribute>()?.GetName();

    private static string? GetHint(PropertyInfo p)
        => p.GetCustomAttribute<DisplayAttribute>()?.GetDescription();

    private static Type EffectiveType(Type t) => Nullable.GetUnderlyingType(t) ?? t;

    private static TypeCode TypeCodeOf(Type t)
        => Type.GetTypeCode(EffectiveType(t));
}
