@using System.ComponentModel.DataAnnotations
@using System.Reflection
@using System.Linq
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using CMC.Web.Services
@using CMC.Web.Util
@using CMC.Web.Pages.FormFields
@using CMC.Web.Pages.FormFields.Types
@using CMC.Contracts.Common

@if (EnableFormSubmit)
{
    <form @onsubmit="HandleFormSubmit" @onsubmit:preventDefault="true" @onkeydown="HandleKeyDown">
        <div class="form-grid">
            @foreach (var field in GetFormFields())
            {
                @RenderFormField(field)
            }
        </div>

        @if (ShowSubmitButton)
        {
            <div class="form-actions mt-4">
                <button type="submit" class="btn @SubmitButtonClass" disabled="@IsSubmitDisabled">
                    @if (IsSubmitDisabled && ShowLoadingSpinner)
                    {
                        <span class="spinner-border spinner-border-sm" role="status"></span>
                        <span> @LoadingText</span>
                    }
                    else
                    {
                        <span>@SubmitButtonText</span>
                    }
                </button>

                @if (ShowCancelButton)
                {
                    <button type="button" class="btn @CancelButtonClass ms-2" @onclick="HandleCancel" disabled="@IsSubmitDisabled">
                        @CancelButtonText
                    </button>
                }
            </div>
        }
    </form>
}
else
{
    <div class="form-grid" @onkeydown="HandleKeyDown">
        @foreach (var field in GetFormFields())
        {
            @RenderFormField(field)
        }
    </div>
}

@code {
    [Parameter] public object? Model { get; set; }
    [Parameter] public List<ExtraField> ExtraFields { get; set; } = new();
    [Parameter] public EventCallback<(string Name, object? Value)> OnFieldChanged { get; set; }
    [Parameter] public EFEditRequest Request { get; set; } = default!;
    [Parameter] public IDictionary<string, object?>? ValueOverrides { get; set; }
    [Parameter] public IReadOnlyDictionary<string, string[]>? ValidationErrors { get; set; }

    // Submit-Parameter
    [Parameter] public bool EnableFormSubmit { get; set; } = false;
    [Parameter] public EventCallback OnSubmit { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }

    // Button-Konfiguration
    [Parameter] public bool ShowSubmitButton { get; set; } = true;
    [Parameter] public bool ShowCancelButton { get; set; } = false;
    [Parameter] public string SubmitButtonText { get; set; } = "Submit";
    [Parameter] public string CancelButtonText { get; set; } = "Cancel";
    [Parameter] public string SubmitButtonClass { get; set; } = "primary";
    [Parameter] public string CancelButtonClass { get; set; } = "secondary";

    // Loading-State
    [Parameter] public bool IsSubmitDisabled { get; set; } = false;
    [Parameter] public bool ShowLoadingSpinner { get; set; } = true;
    [Parameter] public string LoadingText { get; set; } = "Processing...";

    // Enter-Key Handling
    [Parameter] public bool EnableEnterSubmit { get; set; } = true;

    private List<FormFieldDescriptor> GetFormFields()
    {
        var fields = new List<FormFieldDescriptor>();

        if (Model != null)
        {
            foreach (var prop in GetVisibleProps())
                fields.Add(CreateFieldFromProperty(prop));
        }

        foreach (var extra in ExtraFields ?? new())
            fields.Add(CreateFieldFromExtra(extra));

        return fields;
    }

    private FormFieldDescriptor CreateFieldFromProperty(PropertyInfo prop)
    {
        var pType   = EffectiveType(prop.PropertyType);
        var label   = GetDisplayName(prop) ?? prop.Name;
        var current = ResolveCurrentValue(prop.Name, prop.GetValue(Model!));
        var hint    = GetHint(prop);

        var readOnly = prop.GetCustomAttribute<EditorHiddenAttribute>() != null;
        var required = IsRequired(prop);

        // 2FA Felder (Secret zeigt QR)
        if (prop.Name.Contains("TwoFASecret", StringComparison.OrdinalIgnoreCase) ||
            prop.Name.Contains("AuthenticatorSecret", StringComparison.OrdinalIgnoreCase) ||
            prop.GetCustomAttribute<TwoFASecretAttribute>() != null)
        {
            var twoFAAttr = prop.GetCustomAttribute<TwoFASecretAttribute>();

            var issuer = ResolveOverrideValue($"{prop.Name}_Issuer") as string
                ?? twoFAAttr?.Issuer
                ?? "CMC App";

            var accountName = ResolveOverrideValue($"{prop.Name}_AccountName") as string
                ?? GetAccountNameForUser()
                ?? "user@example.com";

            var showSecret = ResolveOverrideValue($"{prop.Name}_ShowSecret") as bool?
                ?? twoFAAttr?.ShowSecret
                ?? false;

            return new FormFieldDescriptor(
                Name: prop.Name,
                Label: label,
                FieldType: typeof(QRCodeField),
                ValueType: prop.PropertyType,
                ReadOnly: readOnly,
                Required: required,
                Hint: hint,
                Value: current,
                Parameters: new()
                {
                    ["Issuer"] = issuer,
                    ["AccountName"] = accountName,
                    ["ShowSecret"] = showSecret
                }
            );
        }

        if (prop.Name.Contains("TwoFACode", StringComparison.OrdinalIgnoreCase) ||
            prop.Name.Contains("AuthenticatorCode", StringComparison.OrdinalIgnoreCase) ||
            prop.GetCustomAttribute<TwoFACodeAttribute>() != null)
        {
            return new FormFieldDescriptor(
                Name: prop.Name,
                Label: label,
                FieldType: typeof(TwoFAInputField),
                ValueType: prop.PropertyType,
                ReadOnly: readOnly,
                Required: required,
                Hint: hint,
                Value: current,
                Parameters: new()
            );
        }

        // Attribut-basierte Relation
        var relAttr = prop.GetCustomAttribute<RelationFromAttribute>();
        if (relAttr != null && Request.EfParentType != null)
        {
            var relationName = TryGetRelationName(relAttr)
                               ?? DeriveRelationName(prop.Name, isMany: relAttr.IsMany);

            if (relAttr.IsMany)
                current = NormalizeKeys(current);

            return new FormFieldDescriptor(
                Name: prop.Name,
                Label: label,
                FieldType: relAttr.IsMany ? typeof(CheckboxListField) : typeof(RelationSelectField),
                ValueType: prop.PropertyType,
                ReadOnly: readOnly,
                Required: required,
                Hint: hint,
                Value: current,
                Parameters: new()
                {
                    ["RelationName"] = relationName,
                    ["ParentType"]   = Request.EfParentType!
                }
            );
        }

        // Heuristik: *Ids => Many-to-Many Checkboxen
        if (Request.EfParentType != null &&
            typeof(System.Collections.IEnumerable).IsAssignableFrom(pType) &&
            pType != typeof(string) &&
            prop.Name.EndsWith("Ids", StringComparison.Ordinal))
        {
            var relationName = DeriveRelationName(prop.Name, isMany: true);
            current = NormalizeKeys(current);

            return new FormFieldDescriptor(
                Name: prop.Name,
                Label: label,
                FieldType: typeof(CheckboxListField),
                ValueType: prop.PropertyType,
                ReadOnly: readOnly,
                Required: required,
                Hint: hint,
                Value: current,
                Parameters: new()
                {
                    ["RelationName"] = relationName,
                    ["ParentType"]   = Request.EfParentType!
                }
            );
        }

        // Heuristik: *Id (Guid/String) => Single-Reference Select
        if (Request.EfParentType != null &&
            (pType == typeof(Guid) || pType == typeof(Guid?) || pType == typeof(string)) &&
            prop.Name.EndsWith("Id", StringComparison.Ordinal) &&
            !prop.Name.EndsWith("Ids", StringComparison.Ordinal))
        {
            var relationName = DeriveRelationName(prop.Name, isMany: false);

            return new FormFieldDescriptor(
                Name: prop.Name,
                Label: label,
                FieldType: typeof(RelationSelectField),
                ValueType: prop.PropertyType,
                ReadOnly: readOnly,
                Required: required,
                Hint: hint,
                Value: current,
                Parameters: new()
                {
                    ["RelationName"] = relationName,
                    ["ParentType"]   = Request.EfParentType!
                }
            );
        }

        // Standard-Feld inkl. Passwort-Spezialfall
        var fieldType  = GetFieldTypeForProperty(pType, prop);
        var parameters = GetParametersForProperty(pType, prop);

        return new FormFieldDescriptor(
            Name: prop.Name,
            Label: label,
            FieldType: fieldType,
            ValueType: prop.PropertyType,
            ReadOnly: readOnly,
            Required: required,
            Hint: hint,
            Value: current,
            Parameters: parameters
        );
    }

    private FormFieldDescriptor CreateFieldFromExtra(ExtraField extra)
    {
        var fieldType  = GetFieldTypeForExtra(extra);
        var parameters = GetParametersForExtra(extra);

        return new FormFieldDescriptor(
            Name:  extra.Name,
            Label: string.IsNullOrWhiteSpace(extra.Label) ? extra.Name : extra.Label!,
            FieldType: fieldType,
            ValueType: extra.Type,
            ReadOnly: extra.ReadOnly,
            Required: extra.Required,
            Hint: extra.Hint,
            Value: ResolveCurrentValue(extra.Name, extra.Value),
            Parameters: parameters
        );
    }

    // Event Handlers
    private async Task HandleFormSubmit()
    {
        if (OnSubmit.HasDelegate)
            await OnSubmit.InvokeAsync();
    }

    private async Task HandleCancel()
    {
        if (OnCancel.HasDelegate)
            await OnCancel.InvokeAsync();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (EnableEnterSubmit && e.Key == "Enter" && !IsSubmitDisabled && OnSubmit.HasDelegate)
            await HandleFormSubmit();
    }

    // Hilfs-Methoden
    private object? ResolveCurrentValue(string name, object? modelValue)
        => (ValueOverrides != null && ValueOverrides.TryGetValue(name, out var v)) ? v : modelValue;

    private object? ResolveOverrideValue(string key)
        => (ValueOverrides != null && ValueOverrides.TryGetValue(key, out var v)) ? v : null;

    private static object? NormalizeKeys(object? value)
    {
        if (value is null) return null;
        if (value is System.Collections.IEnumerable seq && value is not string)
        {
            var list = new List<string>();
            foreach (var e in seq)
                if (e != null)
                    list.Add(e.ToString()!);
            return list;
        }
        return value;
    }

    private static string? TryGetRelationName(RelationFromAttribute attr)
    {
        var t = attr.GetType();
        foreach (var name in new[] { "RelationName", "Name", "Relation", "Navigation", "Property" })
        {
            var p = t.GetProperty(name, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
            var val = p?.GetValue(attr)?.ToString();
            if (!string.IsNullOrWhiteSpace(val))
                return val;
        }
        return null;
    }

    private Type GetFieldTypeForProperty(Type propType, PropertyInfo prop)
    {
        if (prop.Name.Contains("TwoFASecret", StringComparison.OrdinalIgnoreCase) ||
            prop.Name.Contains("AuthenticatorSecret", StringComparison.OrdinalIgnoreCase) ||
            prop.GetCustomAttribute<TwoFASecretAttribute>() != null)
            return typeof(QRCodeField);

        if (prop.Name.Contains("TwoFACode", StringComparison.OrdinalIgnoreCase) ||
            prop.Name.Contains("AuthenticatorCode", StringComparison.OrdinalIgnoreCase) ||
            prop.GetCustomAttribute<TwoFACodeAttribute>() != null)
            return typeof(TwoFAInputField);

        // <<< Passwort-Spezialfall
        if (propType == typeof(string) &&
            prop.Name.Contains("Password", StringComparison.OrdinalIgnoreCase))
            return typeof(PasswordField);

        return TypeCodeOf(propType) switch
        {
            TypeCode.Boolean => typeof(CheckboxField),
            TypeCode.DateTime => typeof(DateTimeField),
            TypeCode.Decimal or TypeCode.Double or TypeCode.Single => typeof(NumberField),
            TypeCode.Int16 or TypeCode.Int32 or TypeCode.Int64 or
            TypeCode.UInt16 or TypeCode.UInt32 or TypeCode.UInt64 => typeof(NumberField),
            _ when propType == typeof(Guid) || propType == typeof(Guid?) => typeof(TextField),
            _ => typeof(TextField)
        };
    }

    private Dictionary<string, object> GetParametersForProperty(Type propType, PropertyInfo prop)
    {
        var parameters = new Dictionary<string, object>();
        var typeCode   = TypeCodeOf(propType);

        if (prop.Name.Contains("TwoFASecret", StringComparison.OrdinalIgnoreCase) ||
            prop.Name.Contains("AuthenticatorSecret", StringComparison.OrdinalIgnoreCase) ||
            prop.GetCustomAttribute<TwoFASecretAttribute>() != null)
        {
            var twoFAAttr = prop.GetCustomAttribute<TwoFASecretAttribute>();

            var issuer = ResolveOverrideValue($"{prop.Name}_Issuer") as string
                ?? twoFAAttr?.Issuer
                ?? "CMC App";

            var accountName = ResolveOverrideValue($"{prop.Name}_AccountName") as string
                ?? GetAccountNameForUser()
                ?? "user@example.com";

            var showSecret = ResolveOverrideValue($"{prop.Name}_ShowSecret") as bool?
                ?? twoFAAttr?.ShowSecret
                ?? false;

            return new Dictionary<string, object>
            {
                ["Issuer"] = issuer,
                ["AccountName"] = accountName,
                ["ShowSecret"] = showSecret
            };
        }

        if (prop.Name.Contains("TwoFACode", StringComparison.OrdinalIgnoreCase) ||
            prop.Name.Contains("AuthenticatorCode", StringComparison.OrdinalIgnoreCase) ||
            prop.GetCustomAttribute<TwoFACodeAttribute>() != null)
            return parameters;

        switch (typeCode)
        {
            case TypeCode.DateTime:
                break;

            case TypeCode.Decimal or TypeCode.Double or TypeCode.Single:
                parameters["Step"] = "any";
                break;

            case TypeCode.Int16 or TypeCode.Int32 or TypeCode.Int64 or
                 TypeCode.UInt16 or TypeCode.UInt32 or TypeCode.UInt64:
                parameters["Step"] = "1";
                break;

            case TypeCode.String:
                if (prop.Name.Contains("Password", StringComparison.OrdinalIgnoreCase))
                {
                    // PasswordField versteht Autocomplete
                    parameters["Autocomplete"] = ResolveOverrideValue($"{prop.Name}_Autocomplete") as string ?? "new-password";
                }
                break;
        }

        if (propType == typeof(Guid) || propType == typeof(Guid?))
            parameters["ReadOnly"] = false;

        return parameters;
    }

    private Type GetFieldTypeForExtra(ExtraField extra)
    {
        if (string.Equals(extra.DataType, "2fa-secret", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(extra.DataType, "qr-code", StringComparison.OrdinalIgnoreCase))
            return typeof(QRCodeField);

        if (string.Equals(extra.DataType, "2fa-code", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(extra.DataType, "totp-code", StringComparison.OrdinalIgnoreCase))
            return typeof(TwoFAInputField);

        if (string.Equals(extra.DataType, "relation-auto", StringComparison.OrdinalIgnoreCase))
        {
            if (extra.Type.IsGenericType && extra.Type.GetGenericTypeDefinition() == typeof(IEnumerable<>))
                return typeof(CheckboxListField);
            return typeof(RelationSelectField);
        }

        if (string.Equals(extra.DataType, "password", StringComparison.OrdinalIgnoreCase))
            return typeof(PasswordField);

        if (extra.Options?.Any() == true)
            return typeof(SelectField);

        return typeof(TextField);
    }

    private Dictionary<string, object> GetParametersForExtra(ExtraField extra)
    {
        var parameters = new Dictionary<string, object>();

        if (string.Equals(extra.DataType, "2fa-secret", StringComparison.OrdinalIgnoreCase) ||
            string.Equals(extra.DataType, "qr-code", StringComparison.OrdinalIgnoreCase))
        {
            var issuer = ResolveOverrideValue($"{extra.Name}_Issuer") as string ?? "CMC App";
            var accountName = ResolveOverrideValue($"{extra.Name}_AccountName") as string ?? GetAccountNameForUser() ?? "user@example.com";
            var showSecret = ResolveOverrideValue($"{extra.Name}_ShowSecret") as bool? ?? false;

            parameters["Issuer"] = issuer;
            parameters["AccountName"] = accountName;
            parameters["ShowSecret"] = showSecret;
        }
        else if (string.Equals(extra.DataType, "2fa-code", StringComparison.OrdinalIgnoreCase) ||
                 string.Equals(extra.DataType, "totp-code", StringComparison.OrdinalIgnoreCase))
        {
            // keine speziellen Parameter
        }
        else if (string.Equals(extra.DataType, "relation-auto", StringComparison.OrdinalIgnoreCase))
        {
            var isMany = extra.Type.IsGenericType && extra.Type.GetGenericTypeDefinition() == typeof(IEnumerable<>);
            var relationName = DeriveRelationName(extra.Name, isMany: isMany);
            parameters["RelationName"] = relationName;
            if (Request.EfParentType != null)
                parameters["ParentType"] = Request.EfParentType!;
        }
        else if (string.Equals(extra.DataType, "password", StringComparison.OrdinalIgnoreCase))
        {
            parameters["Autocomplete"] = "new-password";
        }
        else if (extra.Options?.Any() == true)
        {
            parameters["Options"] = extra.Options!;
        }

        return parameters;
    }

    private string? GetAccountNameForUser()
    {
        if (Model != null)
        {
            var emailProp = Model.GetType().GetProperty("Email", BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);
            var email = emailProp?.GetValue(Model)?.ToString();
            if (!string.IsNullOrWhiteSpace(email))
                return email;
        }
        return null;
    }

    private string[]? ResolveErrors(string name)
        => ValidationErrors != null && ValidationErrors.TryGetValue(name, out var arr) ? arr : null;

    private RenderFragment RenderFormField(FormFieldDescriptor descriptor) => builder =>
    {
        int seq = 0;
        builder.OpenComponent(seq++, descriptor.FieldType);
        builder.AddAttribute(seq++, nameof(FormFieldBase.Name),  descriptor.Name);
        builder.AddAttribute(seq++, nameof(FormFieldBase.Label), descriptor.Label);
        builder.AddAttribute(seq++, nameof(FormFieldBase.Value), descriptor.Value);
        builder.AddAttribute(seq++, nameof(FormFieldBase.ReadOnly),  descriptor.ReadOnly);
        builder.AddAttribute(seq++, nameof(FormFieldBase.Required),  descriptor.Required);
        if (!string.IsNullOrWhiteSpace(descriptor.Hint))
            builder.AddAttribute(seq++, nameof(FormFieldBase.Hint), descriptor.Hint);

        builder.AddAttribute(seq++, nameof(FormFieldBase.Errors), ResolveErrors(descriptor.Name));

        builder.AddAttribute(seq++, nameof(FormFieldBase.OnValueChanged),
            EventCallback.Factory.Create<object?>(this, value => OnFieldChanged.InvokeAsync((descriptor.Name, value))));

        foreach (var param in descriptor.Parameters)
            builder.AddAttribute(seq++, param.Key, param.Value);

        builder.CloseComponent();
    };

    private IEnumerable<PropertyInfo> GetVisibleProps()
    {
        if (Model is null) yield break;

        var type = Model.GetType();
        var allProps = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                           .Where(p => p.CanRead)
                           .ToList();

        foreach (var p in allProps)
        {
            if (string.Equals(p.Name, "Id", StringComparison.Ordinal)) continue;

            var effective = EffectiveType(p.PropertyType);

            var isRelationCandidate =
                p.GetCustomAttribute<RelationFromAttribute>() != null ||
                (p.Name.EndsWith("Ids", StringComparison.Ordinal) &&
                 typeof(System.Collections.IEnumerable).IsAssignableFrom(effective) &&
                 effective != typeof(string)) ||
                (p.Name.EndsWith("Id", StringComparison.Ordinal) &&
                 !string.Equals(p.Name, "Id", StringComparison.Ordinal) &&
                 (effective == typeof(Guid) || effective == typeof(Guid?) || effective == typeof(string)));

            var is2FACandidate =
                p.Name.Contains("TwoFA", StringComparison.OrdinalIgnoreCase) ||
                p.Name.Contains("Authenticator", StringComparison.OrdinalIgnoreCase) ||
                p.GetCustomAttribute<TwoFASecretAttribute>() != null ||
                p.GetCustomAttribute<TwoFACodeAttribute>() != null;

            var scaffold = p.GetCustomAttribute<ScaffoldColumnAttribute>();
            if (scaffold is { Scaffold: false } && !isRelationCandidate && !is2FACandidate) continue;

            var disp = p.GetCustomAttribute<DisplayAttribute>();
            if (disp?.GetAutoGenerateField() == false && !isRelationCandidate && !is2FACandidate) continue;

            if (p.GetCustomAttribute<EditorHiddenAttribute>() is not null && !isRelationCandidate && !is2FACandidate) continue;

            yield return p;
        }
    }

    private static string DeriveRelationName(string fieldName, bool isMany)
    {
        var baseName =
            fieldName.EndsWith("Ids", StringComparison.Ordinal) ? fieldName[..^3] :
            fieldName.EndsWith("Id",  StringComparison.Ordinal) ? fieldName[..^2] :
            fieldName;

        if (!isMany) return baseName;

        return baseName.EndsWith("y", StringComparison.OrdinalIgnoreCase)
            ? baseName[..^1] + "ies"
            : baseName + "s";
    }

    private static string? GetDisplayName(PropertyInfo p)
        => p.GetCustomAttribute<DisplayAttribute>()?.GetName();

    private static string? GetHint(PropertyInfo p)
        => p.GetCustomAttribute<DisplayAttribute>()?.GetDescription();

    private static Type EffectiveType(Type t) => Nullable.GetUnderlyingType(t) ?? t;

    private static TypeCode TypeCodeOf(Type t)
        => Type.GetTypeCode(EffectiveType(t));

    private static bool IsRequired(PropertyInfo prop)
    {
        if (prop.GetCustomAttribute<RequiredAttribute>() != null) return true;

        var t = EffectiveType(prop.PropertyType);
        var isNonNullableValueType = t.IsValueType && Nullable.GetUnderlyingType(prop.PropertyType) == null;

        if (t == typeof(Guid)) return false;

        return isNonNullableValueType;
    }
}
