@using System.ComponentModel.DataAnnotations
@using System.Reflection
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using CMC.Web.Shared
@using CMC.Web.Pages.Shared

<div class="form-grid">
    @if (Model is not null)
    {
        @foreach (var prop in VisibleProps)
        {
            var pType = EffectiveType(prop.PropertyType);
            var label = GetDisplayName(prop) ?? prop.Name;
            var current = prop.GetValue(Model);

            <div class="form-row">
                <label class="form-label">@label</label>

                @switch (TypeCodeOf(pType))
                {
                    case TypeCode.Boolean:
                        {
                            var chk = current as bool? ?? false;
                            <input type="checkbox"
                                   checked="@chk"
                                   @onchange="e => OnBooleanChanged(prop.Name, e)" />
                            break;
                        }
                    case TypeCode.DateTime:
                        {
                            var dt = current as DateTime? ?? default;
                            var val = dt == default ? "" : ToDateTimeLocalValue(dt);
                            <input class="form-control" type="datetime-local"
                                   value="@val"
                                   @onchange="e => OnChanged(prop.Name, ParseDateTimeLocal(e.Value?.ToString()))" />
                            break;
                        }
                    case TypeCode.Decimal:
                        {
                            var dec = current as decimal? ?? 0m;
                            <input class="form-control" type="number"
                                   step="any"
                                   value="@dec"
                                   @onchange="e => OnChanged(prop.Name, ParseDecimal(e.Value?.ToString()))" />
                            break;
                        }
                    case TypeCode.Double:
                    case TypeCode.Single:
                        {
                            var dbl = current is double d ? d : current is float f ? (double)f : 0d;
                            <input class="form-control" type="number"
                                   step="any"
                                   value="@dbl"
                                   @onchange="e => OnChanged(prop.Name, ParseDouble(e.Value?.ToString()))" />
                            break;
                        }
                    case TypeCode.Int16:
                    case TypeCode.Int32:
                    case TypeCode.Int64:
                    case TypeCode.UInt16:
                    case TypeCode.UInt32:
                    case TypeCode.UInt64:
                        {
                            var num = current?.ToString() ?? "0";
                            <input class="form-control" type="number"
                                   step="1"
                                   value="@num"
                                   @onchange="e => OnChanged(prop.Name, ParseLongOrInt(pType, e.Value?.ToString()))" />
                            break;
                        }
                    case TypeCode.String:
                        {
                            var txt = current?.ToString() ?? string.Empty;
                            // Falls ein Property "Password" heißt, maskieren
                            var isPw = prop.Name.Contains("Password", StringComparison.OrdinalIgnoreCase);
                            <input class="form-control"
                                   type="@(isPw ? "password" : "text")"
                                   autocomplete="@(isPw ? "new-password" : null)"
                                   value="@txt"
                                   @onchange="e => OnChanged(prop.Name, e.Value?.ToString())" />
                            break;
                        }
                    default:
                        {
                            if (pType == typeof(Guid))
                            {
                                var gtxt = current?.ToString() ?? string.Empty;
                                <input class="form-control" type="text" value="@gtxt" disabled />
                            }
                            else
                            {
                                var raw = current?.ToString() ?? string.Empty;
                                <input class="form-control" type="text" value="@raw"
                                       @onchange="e => OnChanged(prop.Name, e.Value?.ToString())" />
                            }
                            break;
                        }
                }
            </div>
        }
    }

    @if (ExtraFields?.Count > 0)
    {
        @foreach (var ef in ExtraFields)
        {
            var label = string.IsNullOrWhiteSpace(ef.Label) ? ef.Name : ef.Label;
            var hint  = ef.Hint;

            <div class="form-row">
                <label class="form-label">@label</label>

                @* ---- Relation (Single) via RelationPicker ---- *@
                @if (string.Equals(ef.DataType, "relation-single", StringComparison.OrdinalIgnoreCase))
                {
                    @InitRelationSingleState(ef)

					<RelationPicker IsMany="false"
						Options="@(ef.Options ?? new())"
						ValueSingle="@_relSingle[ef.Name]"
						ValueSingleChanged="@(v => SetRelationSingle(ef.Name, v))"
						OnCreateNew="ef.OnCreateNew"
						OnSearch="ef.OnSearch"
						DebounceMs="ef.DebounceMs"
						Placeholder="Suchen…" />
                }
                else if (string.Equals(ef.DataType, "relation-many", StringComparison.OrdinalIgnoreCase))
                {
                    @InitRelationManyState(ef)

                    <RelationPicker IsMany="true"
                                    Options="@(ef.Options ?? new())"
                                    ValueMany="@_relMany[ef.Name]"
                                    ValueManyChanged="@(vals => SetRelationMany(ef.Name, vals))"
						OnCreateNew="ef.OnCreateNew"
						OnSearch="ef.OnSearch"
						DebounceMs="ef.DebounceMs"
						Placeholder="Suchen…" />
                }
                else if (string.Equals(ef.DataType, "password", StringComparison.OrdinalIgnoreCase))
                {
                    var txt = ef.Value?.ToString() ?? string.Empty;
                    <input class="form-control" type="password"
                           autocomplete="new-password"
                           value="@txt"
                           @onchange="e => OnChanged(ef.Name, e.Value?.ToString())" />
                }
                else if (ef.Options != null && ef.Options.Any())
                {
                    // Einfaches Dropdown
                    var current = ef.Value?.ToString() ?? string.Empty;
                    var isDisabled = ef.ReadOnly;

                    <select class="form-control" disabled="@isDisabled" @onchange="e => OnChanged(ef.Name, e.Value?.ToString())">
                        <option value="">-- bitte wählen --</option>
                        @foreach (var opt in ef.Options)
                        {
                            var selected = string.Equals(opt.Value, current, StringComparison.OrdinalIgnoreCase);
                            <option value="@opt.Value" selected="@selected">@opt.Key</option>
                        }
                    </select>
                }
                else
                {
                    // Textfeld (oder read-only)
                    var txt = ef.Value?.ToString() ?? string.Empty;
                    if (ef.ReadOnly)
                    {
                        <input class="form-control" type="text" value="@txt" disabled />
                    }
                    else
                    {
                        <input class="form-control" type="text" value="@txt" @onchange="e => OnChanged(ef.Name, e.Value?.ToString())" />
                    }
                }

                @if (!string.IsNullOrWhiteSpace(hint))
                {
                    <div class="form-hint">@hint</div>
                }
            </div>
        }
    }
</div>

@code {
    // ===================== Parameters & Cascade ================================
    [Parameter, EditorRequired] public object Model { get; set; } = default!;
    [Parameter] public List<ExtraField> ExtraFields { get; set; } = new();
    [Parameter] public EventCallback<(string Name, object? Value)> OnFieldChanged { get; set; }

    [CascadingParameter] public RequestBuildContext? Ctx { get; set; }

    // ===================== RelationPicker interner State ======================
    private readonly Dictionary<string, string?> _relSingle = new(StringComparer.OrdinalIgnoreCase);
    private readonly Dictionary<string, List<string>> _relMany = new(StringComparer.OrdinalIgnoreCase);

    private RenderFragment InitRelationSingleState(ExtraField ef) => builder =>
    {
        if (!_relSingle.ContainsKey(ef.Name))
            _relSingle[ef.Name] = ef.Value?.ToString();
    };

    private RenderFragment InitRelationManyState(ExtraField ef) => builder =>
    {
        if (!_relMany.ContainsKey(ef.Name))
        {
            // ef.Value kann CSV, IEnumerable<string> oder null sein – wir normalisieren auf List<string>
            var lst = new List<string>();
            if (ef.Value is IEnumerable<string> es) lst = es.ToList();
            else if (ef.Value is string s && !string.IsNullOrWhiteSpace(s)) lst = s.Split(',').Select(x => x.Trim()).Where(x => x.Length > 0).ToList();
            _relMany[ef.Name] = lst;
        }
    };

    private async Task SetRelationSingle(string name, string? value)
    {
        _relSingle[name] = value;
        await OnChanged(name, value);
    }

    private async Task SetRelationMany(string name, List<string> values)
    {
        _relMany[name] = values;
        // ⚠️ Falls du hier echte IEnumerable<Guid> im Request brauchst, musst du die Map-Logik im RequestFactory erweitern.
        await OnChanged(name, values);
    }

    // ===================== Reflection Helpers =================================
    private IEnumerable<PropertyInfo> VisibleProps => GetVisibleProps();

    private IEnumerable<PropertyInfo> GetVisibleProps()
    {
        if (Model is null) yield break;

        var type = Model.GetType();
        foreach (var p in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            if (!p.CanRead) continue;

            var scaffold = p.GetCustomAttribute<ScaffoldColumnAttribute>();
            if (scaffold is { Scaffold: false }) continue;

            var disp = p.GetCustomAttribute<DisplayAttribute>();
            if (disp?.GetAutoGenerateField() == false) continue;

            yield return p;
        }
    }

    private static string? GetDisplayName(PropertyInfo p)
        => p.GetCustomAttribute<DisplayAttribute>()?.GetName();

    // ===================== Typing Helpers =====================================
    private static Type EffectiveType(Type t) => Nullable.GetUnderlyingType(t) ?? t;

    private static TypeCode TypeCodeOf(Type t)
    {
        var et = EffectiveType(t);
        return Type.GetTypeCode(et);
    }

    // ===================== Conversions / Format ===============================
    private static string ToDateTimeLocalValue(DateTime dt)
    {
        var local = dt.Kind == DateTimeKind.Utc ? dt.ToLocalTime() : dt;
        return local.ToString("yyyy-MM-ddTHH:mm");
    }

    private static DateTime? ParseDateTimeLocal(string? s)
        => DateTime.TryParse(s, out var dt) ? dt : null;

    private static decimal? ParseDecimal(string? s)
        => decimal.TryParse(s, System.Globalization.NumberStyles.Any,
                            System.Globalization.CultureInfo.InvariantCulture, out var v) ? v : null;

    private static double? ParseDouble(string? s)
        => double.TryParse(s, System.Globalization.NumberStyles.Any,
                           System.Globalization.CultureInfo.InvariantCulture, out var v) ? v : null;

    private static object? ParseLongOrInt(Type numberType, string? s)
    {
        if (!long.TryParse(s, out var l)) return null;

        var et = EffectiveType(numberType);
        if (et == typeof(int))   return (int) l;
        if (et == typeof(long))  return l;
        if (et == typeof(short)) return (short) l;
        if (et == typeof(uint))  return (uint) Math.Max(0, l);
        if (et == typeof(ulong)) return (ulong) Math.Max(0, l);
        if (et == typeof(ushort))return (ushort) Math.Max(0, l);

        return l;
    }

    // ===================== Change Propagation =================================
    private async Task OnChanged(string name, object? value)
    {
        if (OnFieldChanged.HasDelegate)
            await OnFieldChanged.InvokeAsync((name, value));
    }

    private async Task OnBooleanChanged(string name, ChangeEventArgs e)
    {
        bool? value = null;

        if (e.Value is bool boolValue) value = boolValue;
        else if (e.Value?.ToString() == "on") value = true;
        else if (bool.TryParse(e.Value?.ToString(), out var parsedBool)) value = parsedBool;

        await OnChanged(name, value);
    }
}
