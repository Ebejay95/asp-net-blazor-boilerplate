@using System.ComponentModel.DataAnnotations
@using System.Reflection
@using System.Linq
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web
@using CMC.Web.Pages.Shared
@using CMC.Web.Services
@using CMC.Web.Util
@using CMC.Web.FormFields
@using CMC.Web.FormFields.Types
@using CMC.Contracts.Common

<div class="form-grid">
    @foreach (var field in GetFormFields())
    {
        @RenderFormField(field)
    }
</div>

@code {
    [Parameter] public object? Model { get; set; }
    [Parameter] public List<ExtraField> ExtraFields { get; set; } = new();
    [Parameter] public EventCallback<(string Name, object? Value)> OnFieldChanged { get; set; }
    [Parameter] public EFEditRequest Request { get; set; } = default!;

    private List<FormFieldDescriptor> GetFormFields()
    {
        var fields = new List<FormFieldDescriptor>();

        // Model Properties
        if (Model != null)
        {
            foreach (var prop in GetVisibleProps())
            {
                fields.Add(CreateFieldFromProperty(prop));
            }
        }

        // Extra Fields
        foreach (var extra in ExtraFields ?? new())
        {
            fields.Add(CreateFieldFromExtra(extra));
        }

        return fields;
    }

    private FormFieldDescriptor CreateFieldFromProperty(PropertyInfo prop)
    {
        var pType = EffectiveType(prop.PropertyType);
        var label = GetDisplayName(prop) ?? prop.Name;
        var current = prop.GetValue(Model);
        var hint = GetHint(prop);
        var readOnly = prop.GetCustomAttribute<EditorHiddenAttribute>() != null;

        // Relation Field?
        var relAttr = prop.GetCustomAttribute<RelationFromAttribute>();
        if (relAttr != null && Request.EfParentType != null)
        {
            var relationName = string.IsNullOrWhiteSpace(relAttr.RelationName)
                ? DeriveRelationName(prop.Name)
                : relAttr.RelationName;

            return new FormFieldDescriptor(
                Name: prop.Name,
                Label: label,
                FieldType: relAttr.IsMany ? typeof(CheckboxListField) : typeof(RelationSelectField),
                ValueType: prop.PropertyType,
                ReadOnly: readOnly,
                Hint: hint,
                Value: current,
                Parameters: new Dictionary<string, object>
                {
                    ["RelationName"] = relationName,
                    ["ParentType"] = Request.EfParentType
                }
            );
        }

        // Select Field mit Optionen?
        if (TryGetSelectOptions(prop, out var selectOpts))
        {
            return new FormFieldDescriptor(
                Name: prop.Name,
                Label: label,
                FieldType: typeof(SelectField),
                ValueType: prop.PropertyType,
                ReadOnly: readOnly,
                Hint: hint,
                Value: current,
                Parameters: new Dictionary<string, object>
                {
                    ["Options"] = selectOpts
                }
            );
        }

        // Standard Field Type bestimmen
        var fieldType = GetFieldTypeForProperty(pType);
        var parameters = GetParametersForProperty(pType, prop);

        return new FormFieldDescriptor(
            Name: prop.Name,
            Label: label,
            FieldType: fieldType,
            ValueType: prop.PropertyType,
            ReadOnly: readOnly,
            Hint: hint,
            Value: current,
            Parameters: parameters
        );
    }

    private FormFieldDescriptor CreateFieldFromExtra(ExtraField extra)
    {
        var fieldType = GetFieldTypeForExtra(extra);
        var parameters = GetParametersForExtra(extra);

        return new FormFieldDescriptor(
            Name: extra.Name,
            Label: string.IsNullOrWhiteSpace(extra.Label) ? extra.Name : extra.Label,
            FieldType: fieldType,
            ValueType: extra.Type,
            ReadOnly: extra.ReadOnly,
            Hint: extra.Hint,
            Value: extra.Value,
            Parameters: parameters
        );
    }

    private Type GetFieldTypeForProperty(Type propType)
    {
        return TypeCodeOf(propType) switch
        {
            TypeCode.Boolean => typeof(CheckboxField),
            TypeCode.DateTime => typeof(DateTimeField),
            TypeCode.Decimal or TypeCode.Double or TypeCode.Single => typeof(NumberField),
            TypeCode.Int16 or TypeCode.Int32 or TypeCode.Int64 or
            TypeCode.UInt16 or TypeCode.UInt32 or TypeCode.UInt64 => typeof(NumberField),
            _ when propType == typeof(Guid) => typeof(TextField),
            _ => typeof(TextField)
        };
    }

    private Dictionary<string, object> GetParametersForProperty(Type propType, PropertyInfo prop)
    {
        var parameters = new Dictionary<string, object>();

        var typeCode = TypeCodeOf(propType);
        switch (typeCode)
        {
            case TypeCode.DateTime:
                parameters["InputType"] = "datetime-local";
                break;
            case TypeCode.Decimal or TypeCode.Double or TypeCode.Single:
                parameters["InputType"] = "number";
                parameters["Step"] = "any";
                break;
            case TypeCode.Int16 or TypeCode.Int32 or TypeCode.Int64 or
                 TypeCode.UInt16 or TypeCode.UInt32 or TypeCode.UInt64:
                parameters["InputType"] = "number";
                parameters["Step"] = "1";
                break;
            case TypeCode.String:
                if (prop.Name.Contains("Password", StringComparison.OrdinalIgnoreCase))
                {
                    parameters["InputType"] = "password";
                    parameters["Autocomplete"] = "new-password";
                }
                break;
        }

        if (propType == typeof(Guid))
        {
            parameters["ReadOnly"] = true;
        }

        return parameters;
    }

    private Type GetFieldTypeForExtra(ExtraField extra)
    {
        if (string.Equals(extra.DataType, "relation-auto", StringComparison.OrdinalIgnoreCase))
        {
            // Ableiten ob Many oder Reference basierend auf Type
            if (extra.Type.IsGenericType && extra.Type.GetGenericTypeDefinition() == typeof(IEnumerable<>))
            {
                return typeof(CheckboxListField);
            }
            return typeof(RelationSelectField);
        }

        if (string.Equals(extra.DataType, "password", StringComparison.OrdinalIgnoreCase))
        {
            return typeof(TextField);
        }

        if (extra.Options?.Any() == true)
        {
            return typeof(SelectField);
        }

        return typeof(TextField);
    }

    private Dictionary<string, object> GetParametersForExtra(ExtraField extra)
    {
        var parameters = new Dictionary<string, object>();

        if (string.Equals(extra.DataType, "relation-auto", StringComparison.OrdinalIgnoreCase))
        {
            var relationName = DeriveRelationName(extra.Name);
            parameters["RelationName"] = relationName;
            if (Request.EfParentType != null)
                parameters["ParentType"] = Request.EfParentType;
        }
        else if (string.Equals(extra.DataType, "password", StringComparison.OrdinalIgnoreCase))
        {
            parameters["InputType"] = "password";
            parameters["Autocomplete"] = "new-password";
        }
        else if (extra.Options?.Any() == true)
        {
            parameters["Options"] = extra.Options;
        }

        return parameters;
    }

    private RenderFragment RenderFormField(FormFieldDescriptor descriptor) => builder =>
    {
        int seq = 0;

        builder.OpenComponent(seq++, descriptor.FieldType);
        builder.AddAttribute(seq++, nameof(FormFieldBase.Name), descriptor.Name);
        builder.AddAttribute(seq++, nameof(FormFieldBase.Label), descriptor.Label);
        builder.AddAttribute(seq++, nameof(FormFieldBase.Value), descriptor.Value);
        builder.AddAttribute(seq++, nameof(FormFieldBase.ReadOnly), descriptor.ReadOnly);
        builder.AddAttribute(seq++, nameof(FormFieldBase.Required), descriptor.Required);

        if (!string.IsNullOrWhiteSpace(descriptor.Hint))
            builder.AddAttribute(seq++, nameof(FormFieldBase.Hint), descriptor.Hint);

        builder.AddAttribute(seq++, nameof(FormFieldBase.OnValueChanged),
            EventCallback.Factory.Create<object?>(this, value => OnFieldChanged.InvokeAsync((descriptor.Name, value))));

        // Parameter hinzufügen
        foreach (var param in descriptor.Parameters)
        {
            builder.AddAttribute(seq++, param.Key, param.Value);
        }

        builder.CloseComponent();
    };

    // Hilfsmethoden (aus original FormRenderer übernommen)
    private IEnumerable<PropertyInfo> GetVisibleProps()
    {
        if (Model is null) yield break;

        var type = Model.GetType();
        var allProps = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                           .Where(p => p.CanRead)
                           .ToList();

        var propNames = new HashSet<string>(allProps.Select(p => p.Name), StringComparer.OrdinalIgnoreCase);
        var extraNames = new HashSet<string>((ExtraFields ?? new()).Select(ef => ef.Name), StringComparer.OrdinalIgnoreCase);

        foreach (var p in allProps)
        {
            var scaffold = p.GetCustomAttribute<ScaffoldColumnAttribute>();
            if (scaffold is { Scaffold: false }) continue;

            var disp = p.GetCustomAttribute<DisplayAttribute>();
            if (disp?.GetAutoGenerateField() == false) continue;

            if (p.GetCustomAttribute<EditorHiddenAttribute>() is not null)
                continue;

            var hideIfs = p.GetCustomAttributes<EditorHideIfExistsAttribute>()?.ToList();
            if (hideIfs is { Count: > 0 } &&
                hideIfs.Any(h => propNames.Contains(h.OtherProperty) || extraNames.Contains(h.OtherProperty)))
                continue;

            yield return p;
        }
    }

    private bool TryGetSelectOptions(PropertyInfo p, out List<KeyValuePair<string,string>> options)
    {
        options = new();
        var attr = p.GetCustomAttribute<SelectFromAttribute>();
        if (attr is null) return false;

        try
        {
            var path = attr.SourcePath?.Trim() ?? string.Empty;
            var lastDot = path.LastIndexOf('.');
            if (lastDot <= 0 || lastDot >= path.Length - 1) return false;

            var typeName = path[..lastDot];
            var member = path[(lastDot + 1)..];

            var sourceType = TryResolveType(typeName, p.DeclaringType?.Assembly);
            if (sourceType is null) return false;

            var flags = BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy;
            var field = sourceType.GetField(member, flags);
            var prop = sourceType.GetProperty(member, flags);

            object? raw = field?.GetValue(null) ?? prop?.GetValue(null);
            if (raw is null) return false;

            options = ToOptions(raw);
            return options.Count > 0;
        }
        catch
        {
            return false;
        }
    }

    private Type? TryResolveType(string typeName, Assembly? contextAsm)
    {
        Type? t = null;

        if (contextAsm != null)
        {
            try { t = contextAsm.GetType(typeName, throwOnError: false, ignoreCase: false); } catch { }
            if (t != null) return t;
        }

        if (Request?.ContractsAssembly != null)
        {
            try { t = Request.ContractsAssembly.GetType(typeName, throwOnError: false, ignoreCase: false); } catch { }
            if (t != null) return t;
        }

        foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
        {
            try
            {
                t = asm.GetType(typeName, throwOnError: false, ignoreCase: false);
                if (t != null) return t;
            }
            catch { }
        }

        var asmName = Request?.ContractsAssembly?.GetName().Name ?? contextAsm?.GetName().Name;
        if (!string.IsNullOrWhiteSpace(asmName))
        {
            try { t = Type.GetType($"{typeName}, {asmName}", throwOnError: false); } catch { }
            if (t != null) return t;
        }

        return null;
    }

    private static List<KeyValuePair<string,string>> ToOptions(object? raw)
    {
        var result = new List<KeyValuePair<string,string>>();
        if (raw is not System.Collections.IEnumerable seq) return result;

        foreach (var item in seq)
        {
            if (item is KeyValuePair<string,string> kv)
            {
                result.Add(kv);
                continue;
            }

            var itemStr = item.ToString();
            if (!string.IsNullOrWhiteSpace(itemStr) &&
                itemStr.StartsWith("(") &&
                itemStr.EndsWith(")") &&
                itemStr.Contains(", "))
            {
                var content = itemStr.Substring(1, itemStr.Length - 2);
                var parts = content.Split(new[] { ", " }, 2, StringSplitOptions.None);

                if (parts.Length == 2)
                {
                    var itemLabel = parts[0].Trim();
                    var itemValue = parts[1].Trim();
                    result.Add(new KeyValuePair<string,string>(itemLabel, itemValue));
                    continue;
                }
            }

            var t = item.GetType();

            var labelProp = t.GetProperty("Label") ?? t.GetProperty("Name") ?? t.GetProperty("Text") ?? t.GetProperty("Key");
            var valueProp = t.GetProperty("Tag")   ?? t.GetProperty("Value") ?? t.GetProperty("Id")  ?? t.GetProperty("Key");

            if (labelProp is null && valueProp is null)
            {
                labelProp = t.GetProperty("Item1");
                valueProp = t.GetProperty("Item2");
            }

            var label = labelProp?.GetValue(item)?.ToString();
            var value = valueProp?.GetValue(item)?.ToString();

            label ??= item.ToString() ?? "";
            value ??= label;

            if (!string.IsNullOrWhiteSpace(value))
                result.Add(new KeyValuePair<string,string>(label, value));
        }

        return result;
    }

    private static string? GetDisplayName(PropertyInfo p)
        => p.GetCustomAttribute<DisplayAttribute>()?.GetName();

    private static string? GetHint(PropertyInfo p)
        => p.GetCustomAttribute<DisplayAttribute>()?.GetDescription();

    private static Type EffectiveType(Type t) => Nullable.GetUnderlyingType(t) ?? t;

    private static TypeCode TypeCodeOf(Type t)
    {
        var et = EffectiveType(t);
        return Type.GetTypeCode(et);
    }

    private static string DeriveRelationName(string fieldName)
    {
        if (fieldName.EndsWith("Id", StringComparison.Ordinal))
            return fieldName.Substring(0, fieldName.Length - 2);

        if (fieldName.EndsWith("Ids", StringComparison.Ordinal))
            return fieldName.Substring(0, fieldName.Length - 3);

        return fieldName;
    }
}
